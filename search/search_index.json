{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to IT4U PowerShell Course \u00b6 Intro \u00b6 PowerShell is \"a task automation and configuration management framework from Microsoft, consisting of a command-line shell and associated scripting language\" . It is the easiest way to perform mass Windows Administrator actions, if you know where to look. The PowerShell Docs by Microsoft PowerShell 101 Book This site will be updated weekly as new course material is written / added. If you want to see the source code for this go to the Github link in the upper right hand corner.","title":"Home"},{"location":"index.html#welcome-to-it4u-powershell-course","text":"","title":"Welcome to IT4U PowerShell Course"},{"location":"index.html#intro","text":"PowerShell is \"a task automation and configuration management framework from Microsoft, consisting of a command-line shell and associated scripting language\" . It is the easiest way to perform mass Windows Administrator actions, if you know where to look. The PowerShell Docs by Microsoft PowerShell 101 Book This site will be updated weekly as new course material is written / added. If you want to see the source code for this go to the Github link in the upper right hand corner.","title":"Intro"},{"location":"intro.html","text":"Day 1 \u00b6 Environment Setup \u00b6 The first thing any good SysAdmin / Programmer does is setup their development environment. First we are going to make sure that we know how to start and run PowerShell Press the Win key, then type PowerShell , then hit Enter , this opens a new non-elevated PowerShell instance You may see there are some versions of PowerShell and PowerShell ISE ending with (x86) , these are 32-bit versions of PowerShell If you open a new PowerShell window, but this time right-click and select Run as Administrator , you will open a new PowerShell window with elevated permissions Notice the prompt ends in system32 , this is a good indicator that the current window was launched as Admin Windows comes with a simple PowerShell editor, called PowerShell ISE (Integrated Scripting Environment), open Windows PowerShell ISE ISE Goodness The ISE is a great tool to use. Shipped with every install of PowerShell, it includes syntax highlighting, intellisense, debugging, command search and so much more. A better IDE is VSCode with the PowerShell extension. Let me know if you want me to walk you through this install. Getting used to using the PowerShell CLI \u00b6 Command Aliases \u00b6 If you come from a Linux / Mac background, the PowerShell CLI will be very familiar. Many Bash commands are also aliased to their PowerShell counterpart ex. Bash 1 2 3 cd # change directory pwd # print working directory ls # list PowerShell 1 2 3 Set-Location Get-Locaton Get-ChildItem View Aliases 1 2 Get-Alias # To view all alias' Get-Alias \"command\" # To view the alias of a command, ex. Get-Alias rmdir Getting Help \u00b6 Like every other shell, PowerShell has an integrated helpfile system. Searching by Name 1 Get-Help * file * Retrieving by Name 1 Get-Help Get-FileHash With Examples 1 Get-Help Get-FileHash -Examples Navigating the File System \u00b6 The first thing you should master using any CLI is how to navigate directories. This transfers over to every other shell seamlessly. The only difference is that Windows uses \\ during navigation and Linux/Mac use / during navigation. First, navigate to your Window partition's root folder. Hint You will have to use a combination of cd / Set-Location and ls / Get-ChildItem Your prompt should now look like this: PS C:\\> Navigate back to your user folder, so that your prompt returns back to PS C:\\Users\\Username> Now navigate to your Desktop , -> PS C:\\Users\\Username\\Desktop> View the contents of your desktop using ls or Get-ChildItem Finally navigate back to your home folder using cd .. In PowerShell as well as Bash, . when utilized in a path argument refers to the current directory, and .. refers to the current parent directory. Fastest Route To accomplish the above using the least amount of typing, the commands are: 1 2 3 4 cd \\ cd $home cd .\\ Desktop cd .. The second command uses one of the preset PowerShell variables, $home which returns the home directory of the current logged in user.","title":"Week 1"},{"location":"intro.html#day-1","text":"","title":"Day 1"},{"location":"intro.html#environment-setup","text":"The first thing any good SysAdmin / Programmer does is setup their development environment. First we are going to make sure that we know how to start and run PowerShell Press the Win key, then type PowerShell , then hit Enter , this opens a new non-elevated PowerShell instance You may see there are some versions of PowerShell and PowerShell ISE ending with (x86) , these are 32-bit versions of PowerShell If you open a new PowerShell window, but this time right-click and select Run as Administrator , you will open a new PowerShell window with elevated permissions Notice the prompt ends in system32 , this is a good indicator that the current window was launched as Admin Windows comes with a simple PowerShell editor, called PowerShell ISE (Integrated Scripting Environment), open Windows PowerShell ISE ISE Goodness The ISE is a great tool to use. Shipped with every install of PowerShell, it includes syntax highlighting, intellisense, debugging, command search and so much more. A better IDE is VSCode with the PowerShell extension. Let me know if you want me to walk you through this install.","title":"Environment Setup"},{"location":"intro.html#getting-used-to-using-the-powershell-cli","text":"","title":"Getting used to using the PowerShell CLI"},{"location":"intro.html#command-aliases","text":"If you come from a Linux / Mac background, the PowerShell CLI will be very familiar. Many Bash commands are also aliased to their PowerShell counterpart ex. Bash 1 2 3 cd # change directory pwd # print working directory ls # list PowerShell 1 2 3 Set-Location Get-Locaton Get-ChildItem View Aliases 1 2 Get-Alias # To view all alias' Get-Alias \"command\" # To view the alias of a command, ex. Get-Alias rmdir","title":"Command Aliases"},{"location":"intro.html#getting-help","text":"Like every other shell, PowerShell has an integrated helpfile system. Searching by Name 1 Get-Help * file * Retrieving by Name 1 Get-Help Get-FileHash With Examples 1 Get-Help Get-FileHash -Examples","title":"Getting Help"},{"location":"intro.html#navigating-the-file-system","text":"The first thing you should master using any CLI is how to navigate directories. This transfers over to every other shell seamlessly. The only difference is that Windows uses \\ during navigation and Linux/Mac use / during navigation. First, navigate to your Window partition's root folder. Hint You will have to use a combination of cd / Set-Location and ls / Get-ChildItem Your prompt should now look like this: PS C:\\> Navigate back to your user folder, so that your prompt returns back to PS C:\\Users\\Username> Now navigate to your Desktop , -> PS C:\\Users\\Username\\Desktop> View the contents of your desktop using ls or Get-ChildItem Finally navigate back to your home folder using cd .. In PowerShell as well as Bash, . when utilized in a path argument refers to the current directory, and .. refers to the current parent directory. Fastest Route To accomplish the above using the least amount of typing, the commands are: 1 2 3 4 cd \\ cd $home cd .\\ Desktop cd .. The second command uses one of the preset PowerShell variables, $home which returns the home directory of the current logged in user.","title":"Navigating the File System"},{"location":"pipeline.html","text":"The Pipeline \u00b6 The pipeline is one of the most important concepts in PowerShell. The docs provide a much better explanation than I can provide, so please read them. Boiled down, the pipeline simply means taking the output of one command as the input of a sequential command, with both being separated by a \"pipe\" -> | . ex. 1 2 3 # Simple ping sweep $ping = New-Object System . Net . NetworkInformation . Ping 1 .. 255 | ForEach -Object { if ( $ping . Send ( \"192.168.0.$_\" , 30 ). Status -eq \"Success\" ) { Write-Host \"192.168.0.$_ responded.\" } } Here I am taking the output of the command 1..255 which normally returns an array containing all integers between the bounds specified as the input of the following command. ForEach-Object takes each one of those numbers and performs a ping to 192.168.0.X where X equals that integer. I set a timeout of 30ms, because for this range everything should realistically be reached within 1-5ms. If the ping status return code is \"Success\" then it will Write-Host a string with the IP and a statement saying that it responded. In a ForEach-Object the \\$_ represents the current iteration object, ie. for the first iteration it is 1, then the second it is 2, then 3 etc...","title":"Pipeline"},{"location":"pipeline.html#the-pipeline","text":"The pipeline is one of the most important concepts in PowerShell. The docs provide a much better explanation than I can provide, so please read them. Boiled down, the pipeline simply means taking the output of one command as the input of a sequential command, with both being separated by a \"pipe\" -> | . ex. 1 2 3 # Simple ping sweep $ping = New-Object System . Net . NetworkInformation . Ping 1 .. 255 | ForEach -Object { if ( $ping . Send ( \"192.168.0.$_\" , 30 ). Status -eq \"Success\" ) { Write-Host \"192.168.0.$_ responded.\" } } Here I am taking the output of the command 1..255 which normally returns an array containing all integers between the bounds specified as the input of the following command. ForEach-Object takes each one of those numbers and performs a ping to 192.168.0.X where X equals that integer. I set a timeout of 30ms, because for this range everything should realistically be reached within 1-5ms. If the ping status return code is \"Success\" then it will Write-Host a string with the IP and a statement saying that it responded. In a ForEach-Object the \\$_ represents the current iteration object, ie. for the first iteration it is 1, then the second it is 2, then 3 etc...","title":"The Pipeline"},{"location":"week2.html","text":"Variables, Numbers and Strings \u00b6 The PowerShell language is a weak typed, interpreted language. Insert lengthy explanation here \u2192 Variables \u00b6 Variables are denoted by a dollar sign preceeding a name, ex. 1 2 3 4 $hello = \"Hello\" $world = \" World!\" $hello + $world # Hello World! Having good descriptive varible names is crucial to writing good scripts, and is a practice that carries over to every programming language. When writing a script, try to follow a common naming case scheme like snake_case or camelCase Link to Aricle From about_Variables : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <# A variable is a unit of memory in which values are stored. In PowerShell, variables are represented by text strings that begin with a dollar sign ($), such as $a, $process, or $my_var. Variable names aren't case-sensitive, and can include spaces and special characters. PowerShell variables are loosely typed, which means that they aren't limited to a particular type of object. A single variable can even contain a collection, or array, of different types of objects at the same time. #> ex : $a = 12 # System.Int32 $a = \"Word\" # System.String $a = 12 , \"Word\" # array of System.Int32, System.String $a = Get-ChildItem C : \\ Windows # FileInfo and DirectoryInfo types Numbers \u00b6 Numbers in PowerShell can either be used implicitly, or type cast into a more specific number type. 1 2 3 4 5 6 # Single line comments are denoted by a # at the start of the line # Anything written in a comment is ignored 5 + 5 # Returns 10 [int] \"5\" + 5 # Also returns 10, because the string 5 is type cast to become an integer PowerShell will attempt to type cast all data following a data type to be the same, ex: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function add5 ( [int] $number ) { return $number + 5 ; } add5 ( 10 ) # Returns 15 add5 ( \"hello\" ) <# Returns: add5 : Cannot process argument transformation on parameter 'number'. Cannot convert value \"hello\" to type \"System.Int32\". Error: \"Input string was not in a correct format.\" At line:5 char:5 + add5(\"hello\") + ~~~~~~~~~ + CategoryInfo : InvalidData: (:) [add5], ParameterBindingArgumentTransformationException + FullyQualifiedErrorId : ParameterArgumentTransformationError,add5 #> function addString5 ( [string] $number ) { return $number + 5 ; } addString5 ( 10 ) # Returns 105, because 10 is type cast to be a string, and 5 is type cast to be a string # If the following data is unable to be cast to the first data type, PowerShell will throw an error Strings \u00b6 Strings are sequences of characters, usually arranged in words. In PowerShell you can usually tell something is a string if it is encased in double quotes, \"\", single quotes '', or backticks ``. This article - Variable Substitution has great examples on variable substituion within strings in PowerShell This article from the MS Docs explains all special_Characters Booleans \u00b6 A boolean is either true or false . To a computer this is represented by a single bit. If true, the bit is 1 . If false the bit is 0 . In PowerShell a boolean is represented by $true or $false , null is represented by $null . All about Null This picture is in relation to JavaScript, but the main idea still transfers","title":"Week 2"},{"location":"week2.html#variables-numbers-and-strings","text":"The PowerShell language is a weak typed, interpreted language. Insert lengthy explanation here \u2192","title":"Variables, Numbers and Strings"},{"location":"week2.html#variables","text":"Variables are denoted by a dollar sign preceeding a name, ex. 1 2 3 4 $hello = \"Hello\" $world = \" World!\" $hello + $world # Hello World! Having good descriptive varible names is crucial to writing good scripts, and is a practice that carries over to every programming language. When writing a script, try to follow a common naming case scheme like snake_case or camelCase Link to Aricle From about_Variables : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <# A variable is a unit of memory in which values are stored. In PowerShell, variables are represented by text strings that begin with a dollar sign ($), such as $a, $process, or $my_var. Variable names aren't case-sensitive, and can include spaces and special characters. PowerShell variables are loosely typed, which means that they aren't limited to a particular type of object. A single variable can even contain a collection, or array, of different types of objects at the same time. #> ex : $a = 12 # System.Int32 $a = \"Word\" # System.String $a = 12 , \"Word\" # array of System.Int32, System.String $a = Get-ChildItem C : \\ Windows # FileInfo and DirectoryInfo types","title":"Variables"},{"location":"week2.html#numbers","text":"Numbers in PowerShell can either be used implicitly, or type cast into a more specific number type. 1 2 3 4 5 6 # Single line comments are denoted by a # at the start of the line # Anything written in a comment is ignored 5 + 5 # Returns 10 [int] \"5\" + 5 # Also returns 10, because the string 5 is type cast to become an integer PowerShell will attempt to type cast all data following a data type to be the same, ex: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function add5 ( [int] $number ) { return $number + 5 ; } add5 ( 10 ) # Returns 15 add5 ( \"hello\" ) <# Returns: add5 : Cannot process argument transformation on parameter 'number'. Cannot convert value \"hello\" to type \"System.Int32\". Error: \"Input string was not in a correct format.\" At line:5 char:5 + add5(\"hello\") + ~~~~~~~~~ + CategoryInfo : InvalidData: (:) [add5], ParameterBindingArgumentTransformationException + FullyQualifiedErrorId : ParameterArgumentTransformationError,add5 #> function addString5 ( [string] $number ) { return $number + 5 ; } addString5 ( 10 ) # Returns 105, because 10 is type cast to be a string, and 5 is type cast to be a string # If the following data is unable to be cast to the first data type, PowerShell will throw an error","title":"Numbers"},{"location":"week2.html#strings","text":"Strings are sequences of characters, usually arranged in words. In PowerShell you can usually tell something is a string if it is encased in double quotes, \"\", single quotes '', or backticks ``. This article - Variable Substitution has great examples on variable substituion within strings in PowerShell This article from the MS Docs explains all special_Characters","title":"Strings"},{"location":"week2.html#booleans","text":"A boolean is either true or false . To a computer this is represented by a single bit. If true, the bit is 1 . If false the bit is 0 . In PowerShell a boolean is represented by $true or $false , null is represented by $null . All about Null This picture is in relation to JavaScript, but the main idea still transfers","title":"Booleans"},{"location":"week3.html","text":"After last week's feedback, the style of this course will be transitioning. Instead of teaching you the PowerShell language, I will be focusing on teaching you certain functions , cmdlets and utilities. Get-FileHash Docs \u00b6 We reviewed this cmdlet last week, but here is a usage example. Get-FileHash Example Right click this File , and select Save Link as... and save to your desktop. Open a new PowerShell window and navigate to your desktop with cd $HOME \\ Desktop Calculate the SHA256 hash using Get-FileHash -Path .\\ test_hash . txt -Algorithm SHA256 As you get better at knowing the order of certain command parameters you can omit the flagged names, ie -Path and -Algorithm , for within script usage, it is better to leave the statements verbose so that when you or another person return to the code it is clearer what the code is doing. Now open the file in notepad, either by double clicking on the file or using notepad . exe .\\ test_hash . txt , then delete the last character (a period) then save and close the file. To test to see if the file hash changed, we can use a simple comparison, I have calculated the before value for you. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $oldHash = \"914523DA2E60C0AE77E21AD1EEB827F25508A6B6D984AF3E80E8D292D4ADD24B\" $newHash = Get-FileHash -Path .\\ test_hash . txt -Algorithm SHA256 $hashesEqual = $oldHash -eq $newHash . Hash if ( $hashesEqual ) { $result = \"are\" } else { $result = \"are not\" } Write-Output \"The files $result equal.\" # Should return : \"The files are not the same.\" Now re-add the period back in at the end of the file, and recalculate the above. The result should now be The files are equal. For hashing explanation - Expl Test-NetConnection Docs \u00b6 If a question asks you to check if Port 80 is open on a remote server. Then ping will be of no use to you. This is where Test-NetConnection comes into play. Test-NetConnection allows you to ping a machine and also perform a TCP connection test on a specified port. Testing Internet Connection 1 2 3 4 5 6 7 8 PS C : \\ Users \\ UserName > Test-NetConnection ComputerName : internetbeacon . msedge . net RemoteAddress : 13 . 107 . 4 . 52 InterfaceAlias : Ethernet SourceAddress : 192 . 168 . 0 . 3 PingSucceeded : True PingReplyDetails ( RTT ) : 13 ms Testing a TCP Port 1 2 3 4 5 6 7 8 PS C : \\ Users \\ UserName > Test-NetConnection -ComputerName google . com -Port 80 ComputerName : google . com RemoteAddress : 172 . 217 . 22 . 14 RemotePort : 80 InterfaceAlias : Ethernet SourceAddress : 192 . 168 . 0 . 3 TcpTestSucceeded : True Testing a TCP Port - Verbose 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PS C : \\ Users \\ UserName > Test-NetConnection -ComputerName 8 . 8 . 8 . 8 -Port 53 -InformationLevel Detailed ComputerName : 8 . 8 . 8 . 8 RemoteAddress : 8 . 8 . 8 . 8 RemotePort : 53 NameResolutionResults : 8 . 8 . 8 . 8 dns . google MatchingIPsecRules : NetworkIsolationContext : Internet IsAdmin : False InterfaceAlias : Ethernet SourceAddress : 192 . 168 . 0 . 3 NetRoute ( NextHop ) : 192 . 168 . 0 . 1 TcpTestSucceeded : True Simple Port Sweep PowerShell can also perform a basic port sweep if you want to: This example uses 192.168.0.8 for my example IP, only portscan devices on your local network , doing so across an internet service will likely result in your IP becoming banned . 1 22 .. 80 | % { Test-NetConnection 192 . 168 . 0 . 8 -Port $_ -WarningAction SilentlyContinue | % { Write-Host \"Port $( $_ . RemotePort ) : $( $_ . TcpTestSucceeded ) \" } } % is an alias of ForEach-Object, within scripts utilize the full version, I am using the alias here for saving space netstat Docs \u00b6 NETSTAT.EXE is a crossplatform utility that has been built into Windows for a very long time. This program: \"Displays active TCP connections, ports on which the computer is listening, Ethernet statistics, the IP routing table, IPv4 statistics ..., and IPv6 statistics\" . In short, netstat is the first tool you should turn to when a question asks about an open/listening port on the local machine. This command's usage should transfer over seamlessly to both Mac and Linux. Some of my favorite combos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 netstat -ano <# All TCP and UDP No DNS lookup PID shown #> netstat -r <# Routing table, useful for viewing your default gateway and listing physical interfaces #> netstat -o 5 <# Display active TCP connections and PIDs, loop every 5s #> netstat -a | findstr LISTENING <# List all listening connections / ports. #> netstat -ano | findstr 80 <# Filter by number #> Get-Process / tasklist \u00b6 Moved to next week...","title":"Week 3"},{"location":"week3.html#get-filehash-docs","text":"We reviewed this cmdlet last week, but here is a usage example. Get-FileHash Example Right click this File , and select Save Link as... and save to your desktop. Open a new PowerShell window and navigate to your desktop with cd $HOME \\ Desktop Calculate the SHA256 hash using Get-FileHash -Path .\\ test_hash . txt -Algorithm SHA256 As you get better at knowing the order of certain command parameters you can omit the flagged names, ie -Path and -Algorithm , for within script usage, it is better to leave the statements verbose so that when you or another person return to the code it is clearer what the code is doing. Now open the file in notepad, either by double clicking on the file or using notepad . exe .\\ test_hash . txt , then delete the last character (a period) then save and close the file. To test to see if the file hash changed, we can use a simple comparison, I have calculated the before value for you. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $oldHash = \"914523DA2E60C0AE77E21AD1EEB827F25508A6B6D984AF3E80E8D292D4ADD24B\" $newHash = Get-FileHash -Path .\\ test_hash . txt -Algorithm SHA256 $hashesEqual = $oldHash -eq $newHash . Hash if ( $hashesEqual ) { $result = \"are\" } else { $result = \"are not\" } Write-Output \"The files $result equal.\" # Should return : \"The files are not the same.\" Now re-add the period back in at the end of the file, and recalculate the above. The result should now be The files are equal. For hashing explanation - Expl","title":"Get-FileHash Docs"},{"location":"week3.html#test-netconnection-docs","text":"If a question asks you to check if Port 80 is open on a remote server. Then ping will be of no use to you. This is where Test-NetConnection comes into play. Test-NetConnection allows you to ping a machine and also perform a TCP connection test on a specified port. Testing Internet Connection 1 2 3 4 5 6 7 8 PS C : \\ Users \\ UserName > Test-NetConnection ComputerName : internetbeacon . msedge . net RemoteAddress : 13 . 107 . 4 . 52 InterfaceAlias : Ethernet SourceAddress : 192 . 168 . 0 . 3 PingSucceeded : True PingReplyDetails ( RTT ) : 13 ms Testing a TCP Port 1 2 3 4 5 6 7 8 PS C : \\ Users \\ UserName > Test-NetConnection -ComputerName google . com -Port 80 ComputerName : google . com RemoteAddress : 172 . 217 . 22 . 14 RemotePort : 80 InterfaceAlias : Ethernet SourceAddress : 192 . 168 . 0 . 3 TcpTestSucceeded : True Testing a TCP Port - Verbose 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PS C : \\ Users \\ UserName > Test-NetConnection -ComputerName 8 . 8 . 8 . 8 -Port 53 -InformationLevel Detailed ComputerName : 8 . 8 . 8 . 8 RemoteAddress : 8 . 8 . 8 . 8 RemotePort : 53 NameResolutionResults : 8 . 8 . 8 . 8 dns . google MatchingIPsecRules : NetworkIsolationContext : Internet IsAdmin : False InterfaceAlias : Ethernet SourceAddress : 192 . 168 . 0 . 3 NetRoute ( NextHop ) : 192 . 168 . 0 . 1 TcpTestSucceeded : True Simple Port Sweep PowerShell can also perform a basic port sweep if you want to: This example uses 192.168.0.8 for my example IP, only portscan devices on your local network , doing so across an internet service will likely result in your IP becoming banned . 1 22 .. 80 | % { Test-NetConnection 192 . 168 . 0 . 8 -Port $_ -WarningAction SilentlyContinue | % { Write-Host \"Port $( $_ . RemotePort ) : $( $_ . TcpTestSucceeded ) \" } } % is an alias of ForEach-Object, within scripts utilize the full version, I am using the alias here for saving space","title":"Test-NetConnection Docs"},{"location":"week3.html#netstat-docs","text":"NETSTAT.EXE is a crossplatform utility that has been built into Windows for a very long time. This program: \"Displays active TCP connections, ports on which the computer is listening, Ethernet statistics, the IP routing table, IPv4 statistics ..., and IPv6 statistics\" . In short, netstat is the first tool you should turn to when a question asks about an open/listening port on the local machine. This command's usage should transfer over seamlessly to both Mac and Linux. Some of my favorite combos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 netstat -ano <# All TCP and UDP No DNS lookup PID shown #> netstat -r <# Routing table, useful for viewing your default gateway and listing physical interfaces #> netstat -o 5 <# Display active TCP connections and PIDs, loop every 5s #> netstat -a | findstr LISTENING <# List all listening connections / ports. #> netstat -ano | findstr 80 <# Filter by number #>","title":"netstat Docs"},{"location":"week3.html#get-process-tasklist","text":"Moved to next week...","title":"Get-Process / tasklist"},{"location":"week4.html","text":"Get-NetTCPConnection Docs \u00b6 Functionally similar to NETSTAT , but instead of simply returning a string output, this returns an array of objects, which is a million times more powerful. What ports is Google Chrome communicating on? Copy this simple one-liner and try it on your local machine. 1 Get-Process -Name \"chrome\" | ForEach -Object { Get-NetTCPConnection -OwningProcess $_ . Id -ErrorAction SilentlyContinue } Get-Process Docs \u00b6 I used this in the above command to get all processes with the name of \"chrome\". This command is similar to tasklist , but like Get-NetTCPConnection returns an array of objects. All 1 Get-Process CPU time > 1000s 1 Get-Process | Where-Object { $_ . CPU -gt 1000 } All with a Main Window Title This command shows all processes that have a .mainWindowTitle property, a really good indicator they have a visual interface / window. 1 Get-Process | Where-Object { $_ . mainWindowTitle } | Format-Table Id , Name , mainWindowtitle -AutoSize Custom Function - WhoOwns \u00b6 This simple function serves to demonstrate the advantages of using PowerShell cmdlets over Windows Executables or native binaries. Goal: I want a simple function where I can specify a TCP port on my local machine and know if any process is communicating on that port, and if so what that process' name and PID is. Dirty 1 2 3 4 5 6 7 8 9 10 11 12 13 function WhoOwns ( $port ) { try { $search_pid = (( NETSTAT . EXE -ano | findstr . exe \":$port `t \" ). split ( \" \" ))[- 1 ] $service = (( tasklist . exe | findstr . exe $search_pid ). split ( \" \" ))[ 0 ] } catch { $service = \"No one\" $search_pid = \"no\" } finally { Write-Host \"$service owns port $port with $search_pid PID.\" } } This \"dirty\" version uses NETSTAT and tasklist . While it does accomplish its goal, it is ugly and relies on parsing strings. Such an approach is not wrong , but it is not best practice, and does not scale well. Clean 1 2 3 4 5 6 7 8 9 10 11 12 function WhoOwns ( $port ) { $port_pid = ( Get-NetTCPConnection -LocalPort $port -ErrorAction SilentlyContinue ). OwningProcess if ( $null -ne $port_pid ) { $service = ( Get-Process -Id $port_pid ). ProcessName Write-Host \"$service owns port $port with $port_pid PID.\" } else { Write-Host \"No one owns port $port.\" } } This \"clean\" version utilizes the native PowerShell cmdlets Get-NetTCPConnection and Get-Process , and is a lot more scalable and readable. Test-Path Docs \u00b6 \"The Test-Path cmdlet determines whether all elements of the path exist. It returns $True if all elements exist and $False if any are missing. It can also tell whether the path syntax is valid and whether the path leads to a container or a terminal or leaf element. If the Path is whitespace an empty string, then $False is returned. If the Path is $null, array of $null or empty array, a non-terminating error is returned.\" - Docs In even simpler terms, Test-Path determines whether the entire path to a file / directory exists, including whether that file / directory exists. About Booleans PowerShell is different from other languages in that when you test for a boolean and want to view the result your terminal will return True and False , but when using in scripts and commands, you must use $True and $False . ex. Test-Path $HOME will return True , but if you want to use that in an if statement you must use Test-Path $HOME -eq $True Clear-RecycleBin Docs \u00b6 Simple command to empty recycle bin. Performs same operation as right clicking recycle bin and selecting Empty Recycle Bin All 1 Clear-RecycleBin Specified Drive 1 Clear-RecycleBin -DriveLetter C No Confirm 1 Clear-RecycleBin -Force Tidbits \u00b6 Adding -Confirm:$false to the end of a command that may prompt your for confirmation will bypass that prompt. Adding the -WhatIf flag to commands that accept it will show you a dry run of that command running without changing anything. For checking if a value is $null , have null as the first argument for the comparison, not the second. Add simple functions to your profile so that you can access them in every PS session. To see all the properties and methods on a specific object or class, pipe the command output to Get-Member , ex: Get-Process | Get-Member","title":"Week 4"},{"location":"week4.html#get-nettcpconnection-docs","text":"Functionally similar to NETSTAT , but instead of simply returning a string output, this returns an array of objects, which is a million times more powerful. What ports is Google Chrome communicating on? Copy this simple one-liner and try it on your local machine. 1 Get-Process -Name \"chrome\" | ForEach -Object { Get-NetTCPConnection -OwningProcess $_ . Id -ErrorAction SilentlyContinue }","title":"Get-NetTCPConnection Docs"},{"location":"week4.html#get-process-docs","text":"I used this in the above command to get all processes with the name of \"chrome\". This command is similar to tasklist , but like Get-NetTCPConnection returns an array of objects. All 1 Get-Process CPU time > 1000s 1 Get-Process | Where-Object { $_ . CPU -gt 1000 } All with a Main Window Title This command shows all processes that have a .mainWindowTitle property, a really good indicator they have a visual interface / window. 1 Get-Process | Where-Object { $_ . mainWindowTitle } | Format-Table Id , Name , mainWindowtitle -AutoSize","title":"Get-Process Docs"},{"location":"week4.html#custom-function-whoowns","text":"This simple function serves to demonstrate the advantages of using PowerShell cmdlets over Windows Executables or native binaries. Goal: I want a simple function where I can specify a TCP port on my local machine and know if any process is communicating on that port, and if so what that process' name and PID is. Dirty 1 2 3 4 5 6 7 8 9 10 11 12 13 function WhoOwns ( $port ) { try { $search_pid = (( NETSTAT . EXE -ano | findstr . exe \":$port `t \" ). split ( \" \" ))[- 1 ] $service = (( tasklist . exe | findstr . exe $search_pid ). split ( \" \" ))[ 0 ] } catch { $service = \"No one\" $search_pid = \"no\" } finally { Write-Host \"$service owns port $port with $search_pid PID.\" } } This \"dirty\" version uses NETSTAT and tasklist . While it does accomplish its goal, it is ugly and relies on parsing strings. Such an approach is not wrong , but it is not best practice, and does not scale well. Clean 1 2 3 4 5 6 7 8 9 10 11 12 function WhoOwns ( $port ) { $port_pid = ( Get-NetTCPConnection -LocalPort $port -ErrorAction SilentlyContinue ). OwningProcess if ( $null -ne $port_pid ) { $service = ( Get-Process -Id $port_pid ). ProcessName Write-Host \"$service owns port $port with $port_pid PID.\" } else { Write-Host \"No one owns port $port.\" } } This \"clean\" version utilizes the native PowerShell cmdlets Get-NetTCPConnection and Get-Process , and is a lot more scalable and readable.","title":"Custom Function - WhoOwns"},{"location":"week4.html#test-path-docs","text":"\"The Test-Path cmdlet determines whether all elements of the path exist. It returns $True if all elements exist and $False if any are missing. It can also tell whether the path syntax is valid and whether the path leads to a container or a terminal or leaf element. If the Path is whitespace an empty string, then $False is returned. If the Path is $null, array of $null or empty array, a non-terminating error is returned.\" - Docs In even simpler terms, Test-Path determines whether the entire path to a file / directory exists, including whether that file / directory exists. About Booleans PowerShell is different from other languages in that when you test for a boolean and want to view the result your terminal will return True and False , but when using in scripts and commands, you must use $True and $False . ex. Test-Path $HOME will return True , but if you want to use that in an if statement you must use Test-Path $HOME -eq $True","title":"Test-Path Docs"},{"location":"week4.html#clear-recyclebin-docs","text":"Simple command to empty recycle bin. Performs same operation as right clicking recycle bin and selecting Empty Recycle Bin All 1 Clear-RecycleBin Specified Drive 1 Clear-RecycleBin -DriveLetter C No Confirm 1 Clear-RecycleBin -Force","title":"Clear-RecycleBin Docs"},{"location":"week4.html#tidbits","text":"Adding -Confirm:$false to the end of a command that may prompt your for confirmation will bypass that prompt. Adding the -WhatIf flag to commands that accept it will show you a dry run of that command running without changing anything. For checking if a value is $null , have null as the first argument for the comparison, not the second. Add simple functions to your profile so that you can access them in every PS session. To see all the properties and methods on a specific object or class, pipe the command output to Get-Member , ex: Get-Process | Get-Member","title":"Tidbits"}]}